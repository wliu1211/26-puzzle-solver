#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <queue>
#include <cstdlib>
#include <unordered_set>
#include "state.h"

using namespace std;

void readFile(ifstream& inFile, ofstream& outFile, State &initState, State &goalState);
void printMat(int state[DIM][DIM][DIM], ofstream& outFile);
vector<int> findIndex(int value, int initState[DIM][DIM][DIM]);
void solve(int initState[DIM][DIM][DIM], vector<int> start, int goalState[DIM][DIM][DIM], ofstream& outFile);
State* newState(int mat[DIM][DIM][DIM], int x, int y, int z, int newX, int newY, int newZ, int level, char move, State* parent);
int calculateCost(int initMat[DIM][DIM][DIM], int goalMat[DIM][DIM][DIM]);
void printMoves(State* root, ofstream& outFile);
void printPathValues(State* root, ofstream& outFile);
bool withinMatrix(int x, int y, int z);
bool reachedGoal(int initialArray[DIM][DIM][DIM], int goalArray[DIM][DIM][DIM]);

int const MOVES = 6;

// MOVES = {south, west, north, east, top, bottom}
char moves[MOVES] = {'S', 'W', 'N', 'E', 'T', 'B'};
int depth[MOVES] = {0, 0, 0, 0, -1, 1};
int row[MOVES] = {1, 0, -1, 0, 0, 0};
int col[MOVES] = {0, -1, 0, 1, 0, 0};

// Operator compares two path cost, f(n), values and returns the lower f(n) value
// Where f(n) = g(n) + h(n)
struct comp {
    bool operator()(const State* lhs, const State* rhs) const
    {
        return ( lhs->level + lhs->cost) > (rhs->level + rhs->cost);
    }
};

int main(){
    ifstream inFile;
    ofstream outFile;
    State initState;
    State goalState;
    vector<int> startPoint;
    // Open, read, and solve input file 1
    inFile.open("input1.txt");
    outFile.open("output1.txt");
    readFile(inFile, outFile, initState, goalState);
    startPoint = findIndex(0, initState.mat); // Find and set start point
    solve(initState.mat, startPoint, goalState.mat, outFile);
    outFile.close();

    // Open, read, and solve input file 2
    inFile.open("input2.txt");
    outFile.open("output2.txt");
    readFile(inFile, outFile, initState, goalState);
    startPoint = findIndex(0, initState.mat); // Find and set start point
    solve(initState.mat, startPoint, goalState.mat, outFile);
    outFile.close();

    // Open, read, and solve input file 3
    inFile.open("input3.txt");
    outFile.open("output3.txt");
    readFile(inFile, outFile, initState, goalState);
    startPoint = findIndex(0, initState.mat); // Find and set start point
    solve(initState.mat, startPoint, goalState.mat, outFile);
    outFile.close();
}

void solve(int initState[DIM][DIM][DIM], vector<int> start, int goalState[DIM][DIM][DIM], ofstream& outFile){
    int x, y, z; // Store the location of the start point
    int stateCount = 0;
    priority_queue<State*, vector<State*>, comp> neighbors; // Priority queue to prioritize lowest f(n) value
    unordered_set<State* > explored;
    // Set start point location
    if(start.size() > 0){
        x = start[0]; y = start[1]; z = start[2];
    } else{
        x = 0; y = 0; z = 0;
    }
    
    State* root = newState(initState, x, y, z, x, y, z, 0,'z', NULL); // Create a the initial state
    root->cost = calculateCost(initState, goalState); // Calculate the distance of each tile to the goal tiles 
    neighbors.push(root); // Push the root state into the a priority list
    // Loop when the successors list is not empty
    while (!neighbors.empty()){
        State* min = neighbors.top(); 
        neighbors.pop();
        if (reachedGoal(min->mat, goalState)){
            outFile << min->level<<"\n";
            outFile << stateCount<<"\n";
            printMoves(min, outFile);
            outFile<<"\n";
            printPathValues(min, outFile);
            return;
        }
        explored.insert(min);
        for (int i = 0; i < MOVES; i++){
            if (withinMatrix(min->x + depth[i], min->y +row[i], min->z + col[i])){
                // Create the child node and calculate the cost
                // using the parent node
                State* child = newState(min->mat, 
                                        min->x, 
                                        min->y,
                                        min->z, 
                                        min->x + depth[i], 
                                        min->y + row[i], 
                                        min->z + col[i], 
                                        min->level + 1, 
                                        moves[i],
                                        min);
                child->cost = calculateCost(child->mat, goalState);
                child->move = moves[i];
                // Add child to the neighbor list if the child has not been explored
                // Increase the tree generated by one when it is added 
                if (explored.find(child) == explored.end()) {
                    neighbors.push(child);
                    stateCount++;
                }
            } 
        }   
    }

    delete root;
}

// Creates a new state for the successors
State* newState(int mat[DIM][DIM][DIM], int x, int y, int z, int newX, int newY, int newZ, int level,char move, State* parent){
    State* state = new State;
    int MAX = 27;
    state->parent = parent;
    memcpy(state->mat, mat, sizeof state->mat);
    // Checks if the new movement is within the matrix boundary
    if (withinMatrix(x, y, z) && withinMatrix(newX, newY, newZ)){
        swap(state->mat[x][y][z], state->mat[newX][newY][newZ]);
    };
    state-> level = level;
    state-> x = newX;
    state-> y = newY;
    state-> z = newZ;
    return state;
}

// Reads the file and stores the values into a initial and goal 3x3x3 array 
void readFile(ifstream& inFile, ofstream& outFile, State& initState, State& goalState){
    int lineCount = 0;
    string line;
    if(inFile.is_open()){
        int i = 0, j = 0, k = 0;
        // Read each line of the input file if the program has not reached the end of file
        while(!inFile.eof()){
            if(lineCount < 12){
                getline(inFile, line); // Read each line down
                istringstream iss(line); // Get each number per line
                int initNums = 0;
                // Store each number into the init state array
                while(iss >> initNums){
                    initState.mat[i][j][k] = initNums;
                    k++;
                    if (k == 3) {
                        k = 0;
                        j++;
                        if (j == 3) {
                            j = 0;
                            i++;
                            if (i == 3) {
                                i = 0, j = 0, k = 0;
                                break;
                            }
                        }
                    }
                }
            }else if(lineCount >= 13 && lineCount < 24){
                getline(inFile, line);
                istringstream iss(line);
                int goalNums = 0;
                // Store each number into the goal state array
                while(iss >> goalNums){
                    goalState.mat[i][j][k] = goalNums;
                    k++;
                    if (k == 3) {
                        k = 0;
                        j++;
                        if (j == 3) {
                            j = 0;
                            i++;
                            if (i == 3) {
                                break;
                            }
                        }
                    }
                }
            }
            lineCount++;
        }
        inFile.close();
        printMat(initState.mat, outFile);
        printMat(goalState.mat, outFile);
    }else {
        outFile<< "Unable to open file" << "\n";
    }

}

// searches for the index of the start location or the location of a specific value 
vector<int> findIndex(int value, int initMat[DIM][DIM][DIM]){
    vector<int> location;
    location.resize(3);
    for(int i = 0; i < DIM; ++i) {
        for(int j = 0; j < DIM; ++j) {
            for(int k = 0; k < DIM; ++k) {
                if(initMat[i][j][k] == value) {
                    location[0]=i;
                    location[1]=j;
                    location[2]=k;
                }
            }
        }
    }
    return location;
}

// Print matrix 
void printMat(int state[DIM][DIM][DIM], ofstream& outFile){
     for(int i = 0; i < DIM; ++i) {
        for(int j = 0; j < DIM; ++j) {
            for(int k = 0; k < DIM; ++k) {
                outFile << state[i][j][k] << " ";
            }
            outFile<<"\n";
        }
        outFile<<"\n";
    }
}

// Calculates for the heuristic cost using the Manhattan Distance formula
int calculateCost(int initMat[DIM][DIM][DIM], int goalMat[DIM][DIM][DIM]){
    int count = 0;
    vector<int> initIndex; // 1: <0,0,0>
    vector<int> goalIndex; // 1: <0,1,2>
    // Loops through the matric value
    // Holds the total cost of the state
    int totalCost =0;
    for (int i = 1; i < 27; i++){
        int distance = 0; // Get the distance each tile are away from the goal tile
        initIndex = findIndex(i, initMat); // get the 3 indices for initial state
        goalIndex = findIndex(i, goalMat); // get the 3 indices for initial state
        for(int j = 0; j < DIM; j++){
            int diff = abs(initIndex[j]-goalIndex[j]); // Subtract each x,y,z value to get the distance
            distance += diff;            
        }
        totalCost += distance;
    }
    return totalCost;
}

// Print the moves back to the root state when the goal state is reached
void printMoves(State* root, ofstream& outFile){
    if (root == NULL){
        return;
    }
    printMoves(root->parent, outFile);
    if(root->level != 0){
        outFile <<root->move<< " ";
    }    
}

// Print the path cost back to the root state when the goal state is reached
void printPathValues(State* root, ofstream& outFile){
    if (root == NULL){
        return;
    }
    printPathValues(root->parent, outFile);
    outFile <<root->cost + root->level<< " ";
}

// Checks if the current location is within the matric boundaries
bool withinMatrix(int x, int y, int z){
    if (x >= 0 && x < DIM && y >= 0 && y < DIM && z >= 0 && z < DIM){
        return true;
    }else{
        return false;
    }
}

// Checks if all the values of the initial start are the same as the values in the goal state
bool reachedGoal(int initialArray[DIM][DIM][DIM], int goalArray[DIM][DIM][DIM]) {
    for (int i = 0; i < DIM; ++i) {
        for (int j = 0; j < DIM; ++j) {
            for (int k = 0; k < DIM; ++k) {
                if (initialArray[i][j][k] != goalArray[i][j][k]) {
                    return false;
                }
            }
        }
    }
    return true;
}